Java Annotation

Annotation is a tag that represents the metadata. 
Meta data meant for java tools

It can be present at different levels.
class, interface, methods or fields

It indicates some additional information that can be used by java compiler and JVM.

2 Types 

1. Built-In Annotations  2. Custom Annotations

There are several built-in annoations. 

Built in annotations meant for java code
Eg: 

@Override
@SuppressWarnings
@Deprecated
@FunctionalInterface


Built-In Annotations that are applied to other annotations (to supply more information of the annotation itself)

1. @Target -- target of the annotation
Can have typically these values --CONSTRUCTOR,LOCAL_VARIABLE,FIELD,METHOD,PARAMETER etc.
2. @Retention -- Specifies Retention policy of the annotation.
Can have typically these values
SOURCE
Annotations are to be discarded by the compiler (i.e don't appear in .class file).
eg : @Override

CLASS --Annotations are kept in the class file by the compiler but not retained by the VM at run time. This is the default behavior.


RUNTIME -- Annotations kept in the class file by the compiler and retained by the JVM at run time, so as to read using reflection
eg : @Entity , @WebServlet , @Repository


@Inherited --
Indicates that an annotation type is automatically inherited.
When you apply this annotation to any other annotation i.e. @MyCustomAnnotation; and @MyCustomAnnotation is applied of any class MySuperClass then @MyCustomAnnotation will be available to all sub classes of MySuperClass as well.

@Documented
This annotation indicates that new annotation should be included into java documents generated by java document generator tools.


Meaning of annotations

@Override

@Override annotation assures that the subclass or implementation class method is overriding/implementing the parent class / interface method. If it is not so, compile time error occurs.

@SuppressWarnings

@SuppressWarnings annotation: is used to suppress warnings issued by the compiler. 

eg : @SuppressWarnings("serial")

or
@SuppressWarnings("unchecked")



@Deprecated

@Deprecated annoation marks that this method is deprecated so compiler prints warning. It informs user that it may be removed in the future versions. So, it is better not to use such methods.

----------------------------
Custom Annotations
Java Custom Annotation

Java Custom annotations or Java User-defined annotations are easy to create and use. The @interface element is used to declare an annotation. For example:

@interface MyAnnotation{}  

Here, MyAnnotation is the custom annotation name.

Points to remember for java custom annotation signature (methods in i/f)


Method should not have any throws clauses
Method should return one of the following: primitive data types, String, Class, enum or array of these data types.
Method should not have any parameter.
We should attach @ just before interface keyword to define annotation.
It may assign a default value to the method.

Types of Annotation

There are three types of annotations.

Marker Annotation
Single-Value Annotation
Multi-Value Annotation

1) Marker Annotation

An annotation that has no method, is called marker annotation. For example:

@interface MyAnnotation{}  

eg : @Override , @Deprecated are marker annotations.

2) Single-Value Annotation

An annotation that has one method, is called single-value annotation. For example:

@interface MyAnnotation{  
int value();  
}  
 
We can provide the default value also. For example:

@interface MyAnnotation{  
int value() default 0;  
}  


How to apply Single-Value Annotation

eg :

@MyAnnotation(value=10)  

The value can be anything.

3) Mulit-Value Annotation

An annotation that has more than one method, is called Multi-Value annotation. 
For example:

@interface MyAnnotation{  
 int value1();  
 String value2();  
 String value3();  
  
}  

We can provide the default value also. For example:

@interface MyAnnotation{  
int value1() default 1;  
String value2() default "";  
String value3() default "xyz";  
}  

How to apply Multi-Value Annotation


@MyAnnotation(value1=10,value2="abc",value3="xyz")  


Built-in Annotations used in custom annotations in java

@Target
@Retention
@Inherited
@Documented


Example to specify annoation for a class (i.e before a class definition)

@Target(ElementType.TYPE)  
@interface MyAnnotation{  
int value1();  
String value2();  
}  

Example to specify annoation for a class, methods or fields

@Target({ElementType.TYPE, ElementType.FIELD, ElementType.METHOD})  
@interface MyAnnotation{  
int value1();  
String value2();  
}  

@Retention

@Retention annotation is used to specify to what level annotation will be available.

RetentionPolicy	Availability
RetentionPolicy.SOURCE	refers to the source code, discarded during compilation. It will not be available in the compiled class.
RetentionPolicy.CLASS	refers to the .class file, available to java compiler but not to JVM . It is included in the class file.
RetentionPolicy.RUNTIME	refers to the runtime, available to java compiler and JVM .

Example to specify the RetentionPolicy

@Retention(RetentionPolicy.RUNTIME)  
@Target(ElementType.TYPE)  
@interface MyAnnotation{  
int value1();  
String value2();  
}  


How built-in annotations are used in real scenario?

In real scenario, java programmer only needs to apply annotation. You don't need to create and access annotation. Creating and Accessing annotation is performed by the implementation provider. On behalf of the annotation, java compiler or JVM performs some additional operations.
But in case of custom validations in spring , you can easily create an annotation & use it.

Use Cases for Annotations
Annotations are very powerful and Frameworks like spring and Hibernate use Annotations very extensively for logging and validations. Annotations can be used in places where marker interfaces are used. Marker interfaces are for the complete class but you can define annotation which could be used on individual methods for example whether a certain method is exposed as service method or not.



